import json
import threading
import paho.mqtt.client as mqtt
import hashlib

# Configurações do broker MQTT
broker = "localhost"
port = 1883
topic_challenge = "sd/challenge"
topic_solution = "sd/solution"
client_id = input("Enter ClientID:")

# Variável para indicar se a solução foi encontrada
solution_found = threading.Event()

# Classe para representar uma thread de mineração
class MinerThread(threading.Thread):
    def __init__(self, transaction_id, challenge):
        super().__init__()
        self.transaction_id = transaction_id
        self.challenge = challenge

    def run(self):
        nonce = 0
        while not solution_found.is_set():
            solution = hashlib.sha1(str(nonce).encode()).hexdigest()
            if solution.startswith("0" * self.challenge):
                solution_data = {
                    "ClientID": client_id
                    "TransactionID": self.transaction_id,
                    "Solution": solution
                }
                client.publish(topic_solution, json.dumps(solution_data))
                solution_found.set()  # Sinaliza que a solução foi encontrada
                break
            nonce += 1

# Função para processar a mensagem de desafio
def process_challenge(client, userdata, message):
    payload = json.loads(message.payload)
    transaction_id = payload["TransactionID"]
    challenge = payload["Challenge"]

    print("Recebido novo desafio:")
    print("TransactionID:", transaction_id)
    print("Desafio:", challenge)

    # Cria as threads de mineração
    num_threads = 20
    threads = []
    for _ in range(num_threads):
        thread = MinerThread(transaction_id, challenge)
        thread.start()
        threads.append(thread)

    # Aguarda a solução ser encontrada
    solution_found.wait()

    # Finaliza as demais threads
    for thread in threads:
        if thread.is_alive():
            thread.join()

# Configura o cliente MQTT
client = mqtt.Client()
client.connect(broker, port)

# Assina a fila de mensagens de desafio
client.subscribe(topic_challenge)
client.message_callback_add(topic_challenge, process_challenge)

# Loop principal
while True:
    pass

# Desconecta o cliente MQTT
client.disconnect()
