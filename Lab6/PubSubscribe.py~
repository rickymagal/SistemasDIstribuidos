import json
import paho.mqtt.client as mqtt
import random

# Configurações do broker MQTT
broker = "localhost"
port = 1883
topic_init = "sd/init"
topic_election = "sd/election"
topic_challenge = "sd/challenge"

# Variáveis para controle da eleição
participants = set()
init_messages_received = set()
election_messages_received = set()

# Dados do líder eleito
leader_id = None
leader_vote_id = None

# Função para processar a mensagem de inicialização
def process_init_message(client, userdata, message):
    payload = json.loads(message.payload)
    client_id = payload["ClientID"]

    # Adiciona o participante à lista
    participants.add(client_id)
    init_messages_received.add(client_id)

    if len(init_messages_received) == len(participants):
        # Todos os participantes enviaram suas mensagens de inicialização
        start_election()

# Função para iniciar a fase de eleição
def start_election():
    vote_id = random.randint(0, 65535)  # Gera o VoteID aleatoriamente

    # Publica a mensagem de eleição com o VoteID e o ClientID
    election_data = {
        "ClientID": client_id,
        "VoteID": vote_id
    }
    client.publish(topic_election, json.dumps(election_data))

# Função para processar a mensagem de eleição
def process_election_message(client, userdata, message):
    payload = json.loads(message.payload)
    client_id = payload["ClientID"]
    vote_id = payload["VoteID"]

    election_messages_received.add(client_id)

    if len(election_messages_received) == len(participants):
        # Todos os votos foram recebidos
        elect_leader()

# Função para eleger o líder
def elect_leader():
    global leader_id, leader_vote_id

    max_vote_id = max(election_messages_received, key=lambda client_id: (payload["VoteID"], payload["ClientID"]))
    leader_id = max_vote_id["ClientID"]
    leader_vote_id = max_vote_id["VoteID"]

    # O líder assume o papel de controlador e envia um desafio
    if leader_id == client_id:
       while True:
           user_input = input("Opções:\n1. Publicar novo desafio\n2. Imprimir tabela de transações\n3. Sair\nEscolha uma opção: ")
           if user_input == "3":
               break
           if user_input == "1":
               # Publica um novo desafio
               new_challenge = {
                   "TransactionID": len(transactions),
                   "Challenge": random.randint(1, 6)  # Substitua pelo valor desejado para o challenge
               }
               client.publish(topic_challenge, json.dumps(new_challenge))
               print("Novo desafio publicado:")
               print("TransactionID:", new_challenge["TransactionID"])
               print("Challenge:", new_challenge["Challenge"])
               
               # Adiciona a transação na lista
               new_transaction = {
                   "Challenge": new_challenge["Challenge"],
                   "Solution": None,
                   "Winner": None
               }
               transactions[new_challenge["TransactionID"]] = new_transaction
               
               if user_input == "2":
                   # Update the transaction table
                   print_transactions()


# Função para processar a mensagem de solução
def process_solution(client, userdata, message):
    # Implemente a lógica para processar a mensagem de solução aqui
    pass

# Função para imprimir a tabela de transações
def print_transactions():
    # Implemente a lógica para imprimir a tabela de transações aqui
    pass

# Gera um ClientID aleatório de 16 bits
client_id = str(random.randint(0, 65535))

# Configura o cliente MQTT
client = mqtt.Client()
client.connect(broker, port)

# Assina a fila de mensagens de inicialização
client.subscribe(topic_init)
client.message_callback_add(topic_init, process_init_message)

# Assina a fila de mensagens de eleição
client.subscribe(topic_election)
client.message_callback_add(topic_election, process_election_message)

# Assina a fila de mensagens de solução
client.subscribe(topic_solution)
client.message_callback_add(topic_solution, process_solution)

# Publica a mensagem de inicialização
init_data = {
    "ClientID": client_id
}
client.publish(topic_init, json.dumps(init_data))

# Mantém o cliente MQTT em execução
client.loop_forever()
