from enum import Enum
import grpc
import grpcMiner_pb2
import grpcMiner_pb2_grpc
import pybreaker

def getTransactionId(self) -> int:
    transaction_id = 1
    print("Transaction ID: {0}".format(transaction_id))
    return transaction_id

def getChallenge(self,  transactionID: int) -> int:
    return 1

def getTransactionStatus(self, transactionID: int) -> int:
    return 1

def submitChallenge(self, transactionID: int, clientID: int, solution: str) -> int:
    return 1

def getWinner(self, transactionID: int) -> int:
    return 1

def getSolution(self, transactionID: int) -> int:
    return 1


breaker = pybreaker.CircuitBreaker(fail_max=2, reset_timeout=2)
@breaker

def run(client, n):
    if n == '99':
        print('Adição:')
        x = int(input('Entre com o primeiro número: '))
        y = int(input('Entre com o segundo número: '))
        # raise pybreaker.CircuitBreakerError
        res = client.add(grpcMiner_pb2.args(numOne=x, numTwo=y))
        print(res.num)
    if n == '1':
        print('1. Buscar transactionID atual;')
        print('getTransactionID:')
        # raise pybreaker.CircuitBreakerError
        res = client.getTransactionID(grpcMiner_pb2)
        print(res.num)
    if n == '2':
        print('2. Buscar a challenge (desafio) associada à transactionID atual;')
        print('getChallenge:')
        # raise pybreaker.CircuitBreakerError
        tid = int(input('Entre com o transactionId: '))
        res = client.getChallenge(grpcMiner_pb2.args(transactionId=tid))
        print(res.num)
    if n == '3':
        print('3. Buscar, localmente, uma solução para o desafio proposto')
        print('getTransactionStatus:')
        # raise pybreaker.CircuitBreakerError
        tid = int(input('Entre com o transactionId: '))
        res = client.getTransactionStatus(grpcMiner_pb2.args(transactionId=tid))
        print(res.num)
    if n == '4':
        print('4. Imprimir localmente a solução encontrada;')
        print('getWinner:')
        # raise pybreaker.CircuitBreakerError
        tid = int(input('Entre com o transactionId: '))
        res = client.getWinner(grpcMiner_pb2.args(transactionId=tid))
        print(res.num)
    if n == '5':
        print('5. Submeter a solução ao servidor e aguardar resultado;')
        print('submitChallenge:')
        # raise pybreaker.CircuitBreakerError
        tid = int(input('Entre com o transactionId e o clienteId: '))
        cid = int(input('Entre com o clienteId: '))
        sol = int(input('Entre com o solution'))
        res = client.submitChallenge(grpcMiner_pb2.args(transactionId=tid,clientId=cid, solution=sol))
        print(res.num)
    if n == '6':
        print('6. Imprimir/Decodificar resposta do servidor.')
        print('getSolution:')
        # raise pybreaker.CircuitBreakerError
        tid = int(input('Entre com o transactionId: '))
        res = client.getSolution(grpcMiner_pb2.args(transactionId=tid))
        print(res.num)
    elif n == '0':
        print('Fim.')
        exit()
    else:
        print('Entrada Inválida,')

@breaker
def connect():
    channel = grpc.insecure_channel('localhost:8080')
    client = grpcMiner_pb2_grpc.apiStub(channel)
    while True:
        print('Escolha:')
        print('1 para getTransactionID,')
        print('2 para getChallenge,')
        print('3 para getTransactionStatus')
        print('4 para getWinner,')
        print('5 para submitChallenge')
        print('6 para getSolution()')
        print('99 para add()')
        print('0 para Finalizar')
        print()
        
        n = input('Enter your choice: ')
        
        try:
            running = run(client, n)
            # print(running)
        except pybreaker.CircuitBreakerError:
            print(pybreaker.CircuitBreakerError)


if __name__ == '__main__':
    connect()

